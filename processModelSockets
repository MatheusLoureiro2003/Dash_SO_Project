"""
import os
import pwd
import stat
import socket# ... (restante do código até a função listar_recursos_abertos_processo) ..."""

# MARK: Modificação da Função: listar_recursos_abertos_processo
def listar_recursos_abertos_processo(pid):
    """
    Lista os descritores de arquivo abertos por um processo lendo o diretório /proc/[pid]/fd.
    Para cada descritor, tenta determinar o tipo (arquivo, socket, pipe, etc.) e o caminho/identificador.
    Agora inclui detalhes para sockets de rede.
    Retorna uma lista de dicionários, onde cada dicionário representa um recurso aberto.
    """
"""    recursos_abertos = []
    fd_path = f'/proc/{pid}/fd' # Caminho para o diretório de descritores de arquivo do processo

    all_sockets_network_info = ler_info_sockets_rede()

    try:
        for fd_num_str in os.listdir(fd_path):
            fd_num = int(fd_num_str)
            link_path = os.path.join(fd_path, fd_num_str)

            try:
                real_path = os.readlink(link_path)
                
                # START NEW LINE: Lógica aprimorada para determinar o tipo de recurso
                # Tenta obter o stat do ALVO do link simbólico
                # Se falhar (ex: link quebrado), ainda podemos usar o real_path para algumas inferências
                target_stat = None
                try:
                    target_stat = os.stat(real_path) # Segue o link simbólico para obter o stat do alvo
                except (FileNotFoundError, PermissionError):
                    # Se o alvo não existe ou não temos permissão, target_stat permanece None
                    pass

                tipo_recurso = "Desconhecido"
                detalhes = real_path # Detalhes padrão é o caminho real

                # Prioriza a identificação de Sockets e Pipes pela string do real_path
                if real_path.startswith('socket:['):
                    tipo_recurso = "Socket"
                elif real_path.startswith('pipe:['):
                    tipo_recurso = "Pipe (FIFO)"
                elif real_path.startswith('anon_inode:[eventpoll]'):
                    tipo_recurso = "Anon Inode (Event Poll)"
                elif real_path.startswith('anon_inode:[timerfd]'):
                    tipo_recurso = "Anon Inode (Timer FD)"
                elif real_path.startswith('/dev/'):
                    # Para dispositivos, podemos tentar stat no alvo ou classificar pelo prefixo
                    if target_stat and stat.S_ISCHR(target_stat.st_mode):
                        tipo_recurso = "Dispositivo de Caractere"
                    elif target_stat and stat.S_ISBLK(target_stat.st_mode):
                        tipo_recurso = "Dispositivo de Bloco"
                    else:
                        tipo_recurso = "Dispositivo" # Genérico se não conseguir classificar mais
                elif target_stat:
                    # Se conseguimos stat no alvo, usamos seu tipo real
                    if stat.S_ISREG(target_stat.st_mode):
                        tipo_recurso = "Arquivo Regular"
                    elif stat.S_ISDIR(target_stat.st_mode):
                        tipo_recurso = "Diretório"
                    elif stat.S_ISLNK(target_stat.st_mode): # Target is another symlink
                        tipo_recurso = "Link Simbólico (target)"
                    # Note: S_ISFIFO, S_ISSOCK já tratados por prefixo, mas essa é uma redundância para solidez
                    elif stat.S_ISFIFO(target_stat.st_mode):
                        tipo_recurso = "Pipe (FIFO)"
                    elif stat.S_ISSOCK(target_stat.st_mode):
                        tipo_recurso = "Socket"
                    else:
                        tipo_recurso = "Outro"
                else:
                    # Se não puder obter stat do alvo, e não é um tipo conhecido por prefixo, pode ser um link quebrado ou inacessível.
                    # Manter "Desconhecido" ou "Link Simbólico (alvo inacessível)"
                    tipo_recurso = "Link Simbólico (alvo desconhecido/inacessível)"

                # Detalhamento de Sockets (continua sendo importante)
                if tipo_recurso == "Socket":
                    socket_inode = str(target_stat.st_ino) if target_stat else "N/A" # Usar inode do alvo se disponível
                    if socket_inode in all_sockets_network_info:
                        socket_details = all_sockets_network_info[socket_inode]
                        detalhes = (
                            f"Socket {socket_details['protocolo']} "
                            f"Local: {socket_details['local_address']} "
                            f"Remoto: {socket_details['remote_address']} "
                            f"Estado: {socket_details['estado']}"
                        )
                    else:
                        detalhes = f"Socket (inode: {socket_inode}, detalhes não encontrados em /proc/net)"
                # END NEW LINE

                recursos_abertos.append({
                    "fd": fd_num,
                    "tipo": tipo_recurso,
                    "caminho": real_path,
                    "detalhes": detalhes
                })

            except FileNotFoundError:
                # O link simbólico pode ter sumido (recurso fechado entre listdir e readlink)
                pass 
            except PermissionError:
                recursos_abertos.append({
                    "fd": fd_num,
                    "tipo": "Acesso Negado",
                    "caminho": link_path,
                    "detalhes": "Sem permissão para acessar o recurso"
                })
            except OSError as e:
                recursos_abertos.append({
                    "fd": fd_num,
                    "tipo": "Erro",
                    "caminho": link_path,
                    "detalhes": f"Erro de I/O: {e}"
                })
            except Exception as e:
                recursos_abertos.append({
                    "fd": fd_num,
                    "tipo": "Erro Desconhecido",
                    "caminho": link_path,
                    "detalhes": f"Exceção: {e}"
                })

    except FileNotFoundError:
        pass 
    except PermissionError:
        pass
    except Exception as e:
        print(f"Erro ao listar descritores de arquivo para PID {pid}: {e}")

    return recursos_abertos

# MARK: Bloco de Teste Focado para processModel.py (Novas Funções)
if __name__ == "__main__":
    print("Iniciando testes focados em novas funcionalidades para processModel.py...\n")

    # --- Testando ler_info_sockets_rede_global() ---
    print("--- Teste: _ler_info_sockets_rede_global() ---")
    # Chama a função global diretamente para testar sua funcionalidade
    info_sockets_rede = _ler_info_sockets_rede_global() 
    print(f"Total de sockets de rede encontrados no sistema: {len(info_sockets_rede)}")
    
    if info_sockets_rede:
        print("\nAlguns exemplos de sockets de rede globais (inode: detalhes):")
        count = 0
        for inode, details in info_sockets_rede.items():
            print(f"  Inode: {inode}")
            print(f"    Protocolo: {details.get('protocolo', 'N/A')}")
            print(f"    Local: {details.get('local_address', 'N/A')}")
            print(f"    Remoto: {details.get('remote_address', 'N/A')}")
            print(f"    Estado: {details.get('state', 'N/A')}")
            count += 1
            if count >= 5: # Limita a exibição para os primeiros 5 para brevidade
                print("    ...(mais sockets)")
                break
    else:
        print("Nenhum socket de rede encontrado ou sem permissão para acessar /proc/net.")
    print("-" * 30 + "\n")

    # --- Testando list_posix_named_semaphores() ---
    print("--- Teste: list_posix_named_semaphores() ---")
    posix_sems = list_posix_named_semaphores()
    print(f"Total de semáforos POSIX nomeados encontrados: {len(posix_sems)}")
    if posix_sems:
        print("\nAlguns exemplos de semáforos POSIX nomeados:")
        for i, sem in enumerate(posix_sems[:5]):
            print(f"  {i+1}. Caminho: {sem['caminho']}, Inode: {sem['inode']}, Perms: {sem['perms']}, Tamanho: {sem['tamanho']} bytes")
        if len(posix_sems) > 5:
            print("  ...(mais semáforos POSIX nomeados)")
    else:
        print("Nenhum semáforo POSIX nomeado detectado ou sem permissão para /dev/shm.")
    print("-" * 30 + "\n")



    # --- Testando dicionarioStatusProcesso() com foco em recursos_abertos (incluindo sockets e semáforos) ---
    print("--- Teste: dicionarioStatusProcesso() (foco em recursos abertos aprimorados) ---")
    # dicionarioStatusProcesso() já inicializa _global_network_sockets_info
    status_processos_com_recursos = dicionarioStatusProcesso()
    print(f"Número de processos com status e recursos coletados: {len(status_processos_com_recursos)}")

    # Tenta encontrar um PID com recursos abertos interessantes
    pid_exemplo_recursos = None
    for pid, info in status_processos_com_recursos.items():
        recursos_categorizados = info.get('recursos_abertos', {})
        if (recursos_categorizados.get('semaphores_posix') or
            recursos_categorizados.get('sockets') or
            recursos_categorizados.get('pipes') or
            recursos_categorizados.get('dispositivos') or
            recursos_categorizados.get('arquivos_regulares')): # Garantir que tenha algum recurso
            pid_exemplo_recursos = pid
            break
    
    # Fallback para o primeiro PID se nenhum com recursos interessantes for encontrado
    if not pid_exemplo_recursos and processosTodos():
        pid_exemplo_recursos = processosTodos()[0]

    if pid_exemplo_recursos and pid_exemplo_recursos in status_processos_com_recursos:
        print(f"\nDetalhes de Recursos Abertos para PID de exemplo ({pid_exemplo_recursos}):")
        exemplo_info = status_processos_com_recursos[pid_exemplo_recursos]
        print(f"  Nome do Processo: {exemplo_info.get('nome', 'N/A')}")
        
        recursos = exemplo_info.get('recursos_abertos', {}) # Agora é um dicionário categorizado
        
        # Lista todas as categorias de recursos
        categorias_existentes = False
        for category, items in recursos.items():
            if items and category != 'pid': # 'pid' não é uma categoria de recursos para listar
                categorias_existentes = True
                print(f"\n  Categoria: {category.replace('_', ' ').title()}: ({len(items)} itens)")
                # Exibe até 5 itens por categoria para brevidade
                for i, item in enumerate(items[:5]): 
                    display_str = f"    - FD {item.get('fd', 'N/A')}: Tipo: {item.get('tipo', 'N/A')}"
                    if item.get('caminho'):
                        display_str += f", Caminho/Destino: {item['caminho']}"
                    if item.get('protocolo'): # Para sockets
                        display_str += f", Proto: {item['protocolo']}, Local: {item['local_address']}, Remoto: {item['remote_address']}, Estado: {item['state']}"
                    print(display_str)
                    if 'inode' in item: # Adicionar inode para todos os tipos relevantes
                         print(f"      Inode: {item['inode']}")
                    print("      ---")
                if len(items) > 5:
                    print(f"    ...(mais {len(items) - 5} itens nesta categoria)")
        
        if not categorias_existentes:
            print("  Nenhum recurso aberto detectado ou acesso negado para este processo.")

    else:
        print("\nNão foi possível obter detalhes de recursos para um PID de exemplo ou nenhum processo ativo com recursos.")
    print("-" * 30 + "\n")

    print("Testes focados concluídos para processModel.py.")





    """
    # ----------------------- helpers SYSV -----------------------------
class SemidDs(ctypes.Structure):    # struct semid_ds para semctl
    _fields_ = [
        ("sem_perm_uid", ctypes.c_uint32),  # uid
        ("sem_perm_gid", ctypes.c_uint32),  # gid
        ("sem_perm_mode", ctypes.c_uint16), # permissões
        ("__pad1", ctypes.c_uint16),        # preenchimento
        ("sem_nsems", ctypes.c_uint64),     # número de semáforos no conjunto
        ("__pad2", ctypes.c_uint64 * 2),    # preenchimento
    ]

# Constante para semctl (obter informações de status)
IPC_STAT = 2 #

def _semctl(semid_):
    """
    #Chama semctl(2) para obter informações detalhadas de um conjunto de semáforos SysV.
    """
    ds = SemidDs()
    # semctl(semid, semnum, cmd, arg)
    # semnum = 0 (ignorado para IPC_STAT)
    # cmd = IPC_STAT
    # arg = ponteiro para struct semid_ds
    ret = libc.semctl(semid_, 0, IPC_STAT, ctypes.pointer(ds)) #
    if ret != 0:
        # Erro na chamada semctl, por exemplo, semid inválido ou permissão negada
        return None
    return {
        "semid": semid_,
        "nsems": ds.sem_nsems,
        "perms": oct(ds.sem_perm_mode & 0o777),
        "uid": ds.sem_perm_uid,
        "gid": ds.sem_perm_gid,
    }

def list_sysv_semaphores():
    """
    #Lê /proc/sysvipc/sem e, quando possível, complementa com semctl().
    #Retorna lista de dicionários com detalhes dos semáforos SysV.
    """
    sems = []
    try:
        with open("/proc/sysvipc/sem", 'r') as f: #
            next(f)  # Pula a linha do cabeçalho
            for line in f:
                parts = line.strip().split()
                if len(parts) < 4:
                    continue
                try:
                    semid = int(parts[0])
                    entry = {
                        "tipo": "SYSV",
                        "semid": semid,
                        "key": parts[1],
                        "perms_proc": parts[2], # Permissões como lidas do /proc
                        "nsems_proc": parts[3], # Número de semáforos como lido do /proc
                    }
                    # Tenta obter informações mais detalhadas via semctl
                    extra_info = _semctl(semid)
                    if extra_info:
                        entry.update(extra_info) # Adiciona/sobrescreve com dados de semctl
                    sems.append(entry)
                except ValueError:
                    pass # Ignora linhas mal formatadas
    except (FileNotFoundError, PermissionError):
        pass # Ignora se /proc/sysvipc/sem não existe ou não pode ser acessado
    return sems

    """
"""
